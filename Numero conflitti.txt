Conflitto 1 — Statement: LExpr semplice vs. assegnamento
Descrizione:
Dopo aver riconosciuto un LExpr, il parser si trova di fronte all'ambiguità tra chiudere lo statement (LExpr ;) oppure continuare con un'operazione di assegnamento (LExpr Assignment_op RExpr ;).
Esempio:

c
x;
x = 5;
Causa:
La presenza delle due regole:

go
Stmt ::= LExpr ';'
Stmt ::= LExpr Assignment_op RExpr ';'
Soluzione: PRECEDENZA DEL SECONDO
Questo conflitto è strutturale nei linguaggi C-like. Happy, di default, preferisce shift (attendere altri token). In un progetto didattico questo conflitto può essere considerato accettabile.

Conflitto 2 — FunCall vs. LExpr semplice
Descrizione:
Quando il parser riconosce un identificatore, può sia considerarlo come una chiamata a funzione (se seguito da parentesi), sia come una semplice espressione (LExpr).
Esempio:

c
foo();
bar++;
Causa:
Ambiguità tra regole per chiamate a funzione e statement semplici.
Soluzione: TENERE
Conflitto accettabile, Happy preferisce shift.

Conflitto 3 — Incremento/decremento pre/post
Descrizione:
Le regole di pre-incremento/decremento (++x) e post-incremento/decremento (x++) possono sovrapporsi quando scritte insieme (++x++).
Causa:
Ambiguità tra i livelli di LExpr definiti tramite coercions e regole multiple per incremento/decremento.
Soluzione: VIETARE CASO / DECIDERE COSA FARE
In molti linguaggi costrutti come ++x++ sono vietati; si può raffinare la grammatica per limitarli. Nel progetto attuale il conflitto è tollerabile.

Conflitto 4 — Accesso array vs. identificatore semplice
Descrizione:
Il parser deve decidere se un identificatore seguito da [ debba essere ridotto subito oppure debba attendere ulteriori elementi per un accesso a array.
Esempio:

c
a[3];
b;
Causa:
Regole concorrenti tra BLExpr ::= Ident e BLExpr ::= BLExpr '[' RExpr ']'.
Soluzione: PRECEDENZA DEL PRIMO
Conflitto tipico nei parser LR, risolto tramite shift.

Conflitto 5 — If senza else (dangling else)
Descrizione:
Il classico problema dell'else pendente: il parser deve scegliere a quale if associare l'else in presenza di if annidati senza else.
Esempio:

c
if (a) if (b) x ; else y;
Causa:
La regola SelectionStmt ::= "if" "(" RExpr ")" Stmt "else" Stmt può entrare in conflitto con la versione senza else.
Soluzione: DECIDERE CHE PER OGNI IF C'è SEMPRE ELSE (VERIFICA GO)
Happy associa sempre l’else all’if più vicino; conflitto accettabile.

Conflitto 6 — Coercions tra livelli di espressione
Descrizione:
La presenza di numerosi livelli di espressione (RExprN) generati dalla macro coercions crea conflitti su quando ridurre fra i livelli.
Causa:
Una stessa espressione può essere ridotta a più livelli, generando ambiguità shift/reduce.
Soluzione: TENERE
Stratificare bene gli operatori nelle regole; il conflitto può essere tollerato nel progetto.

Conflitto 7 — Array di puntatori e dereferenziazione
Descrizione:
Ambiguità tra accesso array, puntatore e dereferenziazione.
Esempio:

c
*p[2];
Causa:
Regole concorrenti fra dereferenziazione (*) e accesso array ([...]).
Soluzione: RISOLTO NEL PARSER
Risolto tramite stratificazione dei livelli di LExpr e RExpr; conflitto tipico in parser LR.

Conflitto 8 — Statement di chiamata a funzione vs. statement espressione
Descrizione:
Quando un statement può essere sia una chiamata a funzione che un’espressione generica (LExpr), il parser può trovarsi in conflitto.
Causa:
Regole per Stmt ::= FunCall ';' e Stmt ::= LExpr ';' in sovrapposizione.
Soluzione: PRECEDENZA DEL PRIMO
Conflitto gestibile e documentabile come atteso.

Conflitto 9 — Parametri di funzione variabili
Descrizione:
Ambiguità tra lista vuota di parametri e una lista con un solo elemento, specialmente con separatori opzionali.
Causa:
Macro separator su [Parameter] che genera regole ridondanti.
Soluzione: DA SPIEGARE
Non influenza il parsing di esempi reali, conflitto di implementazione tollerato.

Conflitto 10 — Assegnamenti composti
Descrizione:
Ambiguità tra assegnamento semplice (=) e assegnamento composto (+=, -= etc.) dopo un LExpr.
Esempio:

c
x = 1;
x += 2;
Causa:
Presenza di più regole per Assignment_op.
Soluzione: PRECEDENZE
Conflitto tipico, accettato nei parser LR generati; in linguaggi reali si risolve con precedenze o con specifiche più restrittive.


Conflitto 11 — Ambiguità tra assegnamento e incremento
Descrizione:
Dopo un LExpr, il parser deve decidere se ridurre subito come statement di incremento/decremento (LExpr "++" ;) oppure aspettare un operatore di assegnamento (LExpr "+=" ... ;).
Esempio:

c
x++;
x += 1;
Causa:
Le regole per incremento/decremento postfisso e assegnamento composto sono entrambe possibili.
Soluzione: PRECEDENZ SU +=
Conflitto tipico, accettabile in progetti didattici.

Conflitto 12 — Ambiguità tra chiamata a funzione e accesso array
Descrizione:
Dopo un identificatore seguito da ( o [, il parser deve scegliere tra chiamata a funzione e accesso array.
Esempio:

c
foo(3);
foo[2];
Causa:
Regole parallele per FunCall e BLExpr con accesso array.
Soluzione: PERCHè DA FASTIDIO???
Happy preferisce shift, nessun impatto su parsing reale.

Conflitto 13 — Ambiguità tra statement composto e singolo
Descrizione:
Un blocco { ... } può essere sia uno statement singolo sia parte di una struttura di controllo (if/while/do).
Causa:
Sovrapposizione tra regole per statement composto e statement di controllo.
Soluzione: TENERE
Conflitto gestibile, tipico nelle grammatiche con blocchi opzionali.

Conflitto 14 — Parametri funzione opzionali
Descrizione:
Ambiguità nella distinzione tra chiamata di funzione senza parametri e chiamata con lista vuota o con un solo parametro.
Esempio:

c
foo();
foo(x);
Causa:
Macro separator per parametri e regole con lista vuota.
Soluzione: TENERE/VERIFICARE SEPARATOR PARAMETER
Conflitto strutturale, non crea problemi sul parsing effettivo.

Conflitto 15 — Selezione tra dereferenziazione e pre-incremento
Descrizione:
Dopo il simbolo "*", il parser può interpretare la dereferenziazione (*x) oppure proseguire con un incremento (*++x).
Causa:
Sovrapposizione tra regole di LExpr per dereferenziazione e incremento/decremento.
Soluzione: EVITA QUESTA POSSIBILITà
Conflitto tollerabile, può essere risolto con restrizioni sintattiche più forti.

Conflitto 16 — Ambiguità tra assegnamento e statement semplice su array
Descrizione:
Dopo un accesso array come arr[0], il parser può ridurre subito oppure attendere un operatore di assegnamento.
Esempio:

c
arr[0];
arr[0] = 3;
Causa:
Regole concorrenti per statement su array.
Soluzione: PRECEDENZA DEL SECONDO
Tipico di parser LR, conflitto accettato.

Conflitto 17 — Ambiguità tra do-while e while
Descrizione:
Un blocco seguito da "while" può essere interpretato sia come corpo di un do-while sia come inizio di un ciclo while.
Esempio:

c
do { ... } while (cond);
while (cond) { ... }
Causa:
Sovrapposizione tra regole per do-while e while.
Soluzione: TENERE
Happy preferisce shift, conflitto documentabile come atteso.

Conflitto 18 — Parametri multipli nelle funzioni
Descrizione:
Ambiguità nella separazione dei parametri nelle dichiarazioni o chiamate di funzione.
Esempio:

c
foo(a, b);
Causa:
Macro separator e regole multiple per [Parameter].
Soluzione: GESTIRE CASI
Conflitto strutturale, non influenza parsing reale.

Conflitto 19 — Ambiguità tra return void e return valore
Descrizione:
Il parser può scegliere tra un return senza espressione (return;) o un return con valore (return (x);).
Esempio:

c
return;
return (y);
Causa:
Regole per JumpStmt concorrenti.
Soluzione: TENERE
Conflitto accettato, gestito dal parser.

Conflitto 20 — Ambiguità tra uso di variabile e statement void
Descrizione:
Un identificatore può essere interpretato sia come uso di variabile sia come statement void.
Esempio:

c
x;
foo();
Causa:
Regole per LExpr e FunCall in concorrenza.
Soluzione: TENERE
Conflitto tipico, accettato in parser LR.

Conflitto 21 — Ambiguità tra variabile e assegnamento a variabile
Descrizione:
Dopo aver riconosciuto un identificatore, il parser può ridurre subito a statement o attendere per un eventuale assegnamento.
Esempio:

c
y;
y = 1;
Causa:
Regole parallele per statement e assegnamento.
Soluzione: PRECEDENZA DEL SECONDO
Conflitto strutturale, documentabile come accettato.

Conflitto 22 — Lista di dichiarazioni vs dichiarazione singola
Descrizione:
Ambiguità tra lista vuota, lista con un solo elemento o lista con più elementi nelle dichiarazioni.
Causa:
Macro separator sulle dichiarazioni.
Soluzione: GESTIRE CASI
Conflitto di implementazione, non influenza la correttezza del parser.

Conflitto 23 — Ambiguità tra chiamata a funzione e dereferenziazione
Descrizione:
Un identificatore seguito da ( o * può essere interpretato come chiamata a funzione o come dereferenziazione di un puntatore a funzione.
Esempio:

c
(*foo)();
foo();
Causa:
Regole per FunCall e dereferenziazione concorrenti.
Soluzione: TENERE
Conflitto tollerato, risolto tramite shift.

Conflitto 24 — Ambiguità tra statement, assegnamento e statement composto
Descrizione:
Dopo una variabile o un’espressione, il parser può interpretare come statement semplice, assegnamento o come inizio di uno statement composto/blocco.
Causa:
Sovrapposizione di regole tra LExpr, statement e blocchi.
Soluzione: TENERE
Tipico delle grammatiche per linguaggi imperativi, conflitto accettabile.